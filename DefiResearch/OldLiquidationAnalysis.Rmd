---
title: "Old Liquidation Analysis: "
author: "Roman Vakhrushev (vakhrr,golcz)"
date: "04/29/2021"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
subtitle: "DeFi"
always_allow_html: true
---

```{r setup, include=FALSE}
# Set the default CRAN repository
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})

# Set code chunk defaults
knitr::opts_chunk$set(echo = TRUE)

# Load required packages; install if necessary
# CAUTION: DO NOT interrupt R as it installs packages!!
if (!require("ggplot2")) {
  install.packages("ggplot2")
  library(ggplot2)
}
if (!require("gplots")) {
  install.packages("gplots")
  library(gplots)
}

if (!require("knitr")) {
  install.packages("knitr")
  library(knitr)
}

if (!require("dplyr")) {
  install.packages("dplyr")
  library(dp)
}

if (!require("RColorBrewer")) {
  install.packages("RColorBrewer")
  library(RColorBrewer)
}
if (!require("beeswarm")) {
  install.packages("beeswarm")
  library(beeswarm)
}
if (!require("tidyverse")) {
  install.packages("tidyverse")
  library(tidyverse)
}
if (!require("ggbeeswarm")) {
  install.packages("ggbeeswarm")
  library(ggbeeswarm)
}
if (!require("xts")) {
  install.packages("xts")
  library(xts)
}
if (!require("plotly")) {
  install.packages("plotly")
  library(plotly)
}
if (!require("ggrepel")) {
  install.packages("ggrepel")
  library(ggrepel)
}
if (!require("sjmisc")) {
  install.packages("sjmisc")
  library(sjmisc)
}
if (!require("sjmisc")) {
  install.packages("sjmisc")
  library(sjmisc)
}
if (!require("lubridate")) {
  install.packages("lubridate")
  library(lubridate)
}

if (!require("rpart")) {
  install.packages("rpart")
  library(rpart)
}

if (!require("randomForest")) {
  install.packages("randomForest")
  library(randomForest)
}


```

```{r}
#data collection as always
df<-read_rds('./Data/transactionsv2.rds')
# Use deplyr to drop NA reserves, add the counts and then kep only the top 20
reservecoins <- df %>%  drop_na(reserve) %>% 
count(reserve) %>% 
arrange(-n) %>% 
head(20)
```

```{R}
#function to mark stable and non-stable coins
coinType <- function(coin) {
    #stable_coins <- list("USDC","USDT","DAI","BUSD","SUSD","GUSD","TUSD")
    if(str_contains(coin,"USD",ignore.case = TRUE))
    {
      result = "stable"
    }
    else if(str_contains(coin,"DAI",ignore.case = TRUE))
    {
      result = "stable"
    }
    else
    {
      result = "non-stable"
    }
    return(result)
}

defLiquid <- function(principal, collateral) {
  if(collateral < principal)
  {
    result = TRUE
  }
  else
  {
    result = FALSE
  }
  return(result)
}

```

### Deficient Liquidators

Let's start by building a dataframe for deficient liquidations and computing the percentage of deficient liquidations over all liquidations.

```{R}
#Show transactions, where collateral<principal (exclude WETH and AmmWETH for now). 
dfst <- df %>% filter(type == "liquidation") %>%  filter(amountUSDCollateral<amountUSDPincipal)

dfst$collateralType <- mapply(coinType, dfst$collateralReserve)
dfst$principalType <- mapply(coinType, dfst$principalReserve)

dfst <- dfst %>% group_by(user) %>% summarize(num_def = n(),total_collateral = sum(amountUSDCollateral), total_principal = sum(amountUSDPincipal)) %>% mutate(percent = total_collateral/total_principal * 100)

head(dfst,10)

#plot <- ggplot(dfst,aes(y = total_collateral,x = total_principal,color = as.factor(n))) + geom_point() + ggtitle("Deficient Liquidators") + geom_abline() + xlab("Total Collateral(USD)") + ylab("Total Principal(USD)") 
  
plot <- ggplot(dfst,aes(y = total_collateral,x = total_principal,color = as.factor(num_def))) + geom_point() + ggtitle("Deficient Liquidators") + geom_abline() + labs(title = "Deficient Liquidators", x = "Total Collateral(USD)", y = "Total Principal(USD)", color = "Total transactions")

dfst <- dfst[order(dfst$percent),]

dfst <- dfst %>% rownames_to_column('user_number') 

dfst$user_number <- as.integer(dfst$user_number)

plot2 <- ggplot(dfst,aes(y = percent, x = user_number)) + geom_bar(stat="identity", position=position_dodge()) + labs(title = "Percent Distribution", x = "Deficient Liquidators (ordered by percent)", y = "Percent")

#ggplotly(plot)

plot

plot2
```
The table (part of it) and graph above show the data on deficient liquidators. There are 154 deficient liquidators in our data (people who made at least 1 deficient liquidation). All of the figures above were built around total numbers for collateral and principal used in all deficient liquidations for different users. Percent in the table (and barplot) means total_collateral/total_principal * 100. As we can see from the table, both the number of deficient liquidations and percent can be different. Number of deficient liquidations is skewed towards low numbers, which makes sense since we do not expect users to make a lot of deficient liquidations. At the same time, percent varies a lot from low numbers to high numbers. Additionally the barplot above was created just to illustrate the distribution of percent variable over deficient liquidators. It looks like some deficient liquidations cannot be explained by just small fluctuations in price: the percent for many users is way below 50, which means the difference between principal and collateral values was very significant. From the graph, we can tell that there are two outliers: users that did several liquidations with very big trading volume, and probably lost a lot of money due to these liquidations. Other than that, the rest of the users are concentrated near (0,0) and never exceed 300000 USD in collateral and 170000 USD in principal. 

```{R}
#deficient users data
defusers <- df %>% filter(user %in% dfst$user)

defusers_liq <- defusers %>% filter(type == "liquidation") 

defusers_liq$deficiency <- mapply(defLiquid,defusers_liq$amountUSDPincipal,defusers_liq$amountUSDCollateral)

defusers_liq <- defusers_liq %>% group_by(user) %>% summarize(num = n(), num_def = sum(ifelse(deficiency,1,0))) %>% mutate(percent_def = num_def/num * 100)

head(defusers_liq,10)

defusers_liq <- defusers_liq[order(defusers_liq$percent_def),]

defusers_liq <- defusers_liq %>% rownames_to_column('user_number') 

defusers_liq$user_number <- as.integer(defusers_liq$user_number)

plot3 <- ggplot(defusers_liq,aes(y = percent_def, x = user_number)) + geom_bar(stat="identity", position=position_dodge()) + labs(title = "Deficiency Percent Distribution", x = "Deficient Liquidators (ordered by deficiency percent)", y = "Deficiency Percent")

plot3

```
Let's take a look into these deficient liquidators more closely. First let's check how regular vs deficient liquidations they make. The table (part is shown) gives us some insights. First, we observe a lot of deficient liquidators made only a few liquidations overall, sometimes even one liquidation in total (and it was deficient). However, there are some users that made a lot of liquidations, sometimes even more than 40 (and up to 5 deficient ones). We can also take a look into deficiency percent (ratio of number of deficient liquidations over all liquidations done by particular user) of the deficient liquidators. The barplot shows the destribution of this parameter over users. Its easy to see that there are some flat parts in the barplot. This is because a lot of users made a few liquidations and many of them got the same deficiency percent (i.e. 100% is usually 1 deficient liquidation/ 1 liquidation total). Besides this group of few-time liquidators, we can see that some users have their deficiency percent really close to 0, which means they make a lot of profitable liquidations and a few deficient ones may be just a coincidence.
```{R}
#create groups: deficient and regular users
bd_def <- defusers %>% group_by(type) %>% summarize(n=n())%>% mutate(percent = n/sum(n)*100)

bd_reg <- df %>% group_by(type) %>% summarize(n=n())%>% mutate(percent = n/sum(n)*100)

bd_def$group <-'deficient_liquidators'

bd_reg$group <-'regular_users'

bd_joint <- rbind(bd_def, bd_reg)
```

```{R}

plot <- ggplot(data=bd_joint, aes(x=type, y=percent, fill=group)) +
geom_bar(stat="identity", position=position_dodge()) + ggtitle("All Users vs Deficient-Liquidation Users by Types of Transactions")

ggplotly(plot)

```
We can also try to analyze this population of deficient liquidators not only from liquidation perspective, but also from various other points of view. The barplot above shows the breakdown of different types of transaction for deficient liquidators and regular users. We can see that the two groups look quite differently from this point of view. First, deficient liquidators make a lot more liquidations compared to regular users. This is probably due to the fact that there are just a lot more liquidators in the corresponding group, so they are more active with this type of transaction. Secondly, deficient liquidators make more borrows and repays than regular users. This could also be explained from the liquidation perspective: liquidators need to borrow corresponding cryptocurrency to do liquidations, and after they get the collateral from liquidation, they repay their loans. 
```{R}

#Deficiency coins

defusers_lc_coins <- defusers %>% filter(type == "liquidation") %>% group_by(collateralReserve) %>% summarize(n = n())

defusers_lp_coins <- defusers %>% filter(type == "liquidation") %>% group_by(principalReserve) %>% summarize(n = n())

#head(defusers_lc_coins[order(-defusers_lc_coins$n),],10)

#head(defusers_lp_coins[order(-defusers_lp_coins$n),],10)


```

```{R}

#Regular coins

regusers_lc_coins <- df %>% filter(type == "liquidation") %>% group_by(collateralReserve) %>% summarize(n = n())

regusers_lp_coins <- df %>% filter(type == "liquidation") %>% group_by(principalReserve) %>% summarize(n = n())

#head(regusers_lc_coins[order(-regusers_lc_coins$n),],10)

#head(regusers_lp_coins[order(-regusers_lp_coins$n),],10)


```
```{R}

defusers$group <-'deficient'

df$group <-'regular'



LiquidSummaryDef <- defusers %>% filter(type == "liquidation") %>% group_by(collateralReserve, principalReserve) %>% summarize(avg_usd_princ = mean(amountUSDPincipal),total_usd_princ = sum(amountUSDPincipal), avg_usd_collat=mean(amountUSDCollateral),total_usd_collat=sum(amountUSDCollateral),avg_eth_princ = mean(reservePriceETHPrincipal*principalAmount),total_eth_princ = sum(reservePriceETHPrincipal*principalAmount), avg_eth_collat=mean(reservePriceETHCollateral*collateralAmount),total_eth_collat=sum(reservePriceETHCollateral*collateralAmount),collateralType = coinType(collateralReserve), principalType = coinType(principalReserve),n=n())


LiquidSummaryReg <- df %>% filter(type == "liquidation") %>% group_by(collateralReserve, principalReserve) %>% summarize(avg_usd_princ = mean(amountUSDPincipal),total_usd_princ = sum(amountUSDPincipal), avg_usd_collat=mean(amountUSDCollateral),total_usd_collat=sum(amountUSDCollateral),avg_eth_princ = mean(reservePriceETHPrincipal*principalAmount),total_eth_princ = sum(reservePriceETHPrincipal*principalAmount), avg_eth_collat=mean(reservePriceETHCollateral*collateralAmount),total_eth_collat=sum(reservePriceETHCollateral*collateralAmount),collateralType = coinType(collateralReserve), principalType = coinType(principalReserve),n=n())


p_avg_def <- ggplot(LiquidSummaryDef,aes(avg_usd_princ,avg_usd_collat,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidation Coins - \nDeficient-Liquidation Users (Average Value)") + geom_text(aes(label=ifelse(avg_usd_princ>2.0e+05|avg_usd_collat>2.0e+05,paste(as.character(collateralReserve), as.character(principalReserve), sep=";"),'')),hjust=0,vjust=1) + geom_abline()  + xlab("Average Principal (USD)") + ylab("Average Collateral (USD)")

p_avg_reg <- ggplot(LiquidSummaryReg,aes(avg_usd_princ,avg_usd_collat,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidation Coins - All Users (Average Value)") + geom_text(aes(label=ifelse(avg_usd_princ>2.0e+05|avg_usd_collat>2.0e+05,paste(as.character(collateralReserve), as.character(principalReserve), sep=";"),'')),hjust=0,vjust=1) + geom_abline()  + xlab("Average Principal (USD)") + ylab("Average Collateral (USD)")

p_avg_def

p_avg_reg
```
I also wanted to take a look into different kinds of coins that were popular in deficient vs profitable liquidations. The two graphs above show the most popular coin combinations for liquidations of deficient liquidators and all users correspondingly. We can observe a number of interesting differences, although for the most part (the most popular coin combinations) the graphs look similar. For example, deficient liquidators almost never use stable coins for transactions, but this might just be due to smaller data set for deficient liquidators (liquidations involving stable coins are rare in regular data set as well).


### Graphs from Papers
```{R}
#graphs from paper of liquidations
dfst <- df %>% filter(type == "liquidation") %>%  filter(amountUSDCollateral<amountUSDPincipal)

dfst$collateralType <- mapply(coinType, dfst$collateralReserve)
dfst$principalType <- mapply(coinType, dfst$principalReserve)

#dfst

dfstsushi <- dfst %>% filter(collateralReserve == "XSUSHI")

dfsushi <- df %>% filter(reserve == "XSUSHI" )

sushi.plot <- ggplot(dfsushi, aes(x = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSD)) + geom_line() + geom_point(data = dfstsushi, aes(x = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSDCollateral), color = "red") + ggtitle("Price and Deficient Liquidations of XSUSHI") + ylab("Price of XSUSHI, USD") + xlab("Time")

#ggplotly(sushi.plot)

sushi.plot

```
```{R}
#graphs from paper of liquidations
dfst <- df %>% filter(type == "liquidation") %>%  filter(amountUSDCollateral<amountUSDPincipal)

dfst$collateralType <- mapply(coinType, dfst$collateralReserve)
dfst$principalType <- mapply(coinType, dfst$principalReserve)

dfstenj <- dfst %>% filter(collateralReserve == "ENJ")

dfenj <- df %>% filter(reserve == "ENJ" )

enj.plot <- ggplot(dfenj, aes(x = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSD)) + geom_line() + geom_point(data = dfstenj, aes(x = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSDCollateral), color = "red") + ggtitle("Price and Deficient Liquidations of ENJ") + ylab("Price of ENJ, USD") + xlab("Time")

#ggplotly(enj.plot)

enj.plot

```
```{R}
#dfst <- df %>% filter(type == "liquidation") %>%  #filter(amountUSDCollateral<amountUSDPincipal)

#dfst$collateralType <- mapply(coinType, dfst$collateralReserve)
#dfst$principalType <- mapply(coinType, dfst$principalReserve)

#dfstamm <- dfst %>% filter(collateralReserve == "AmmBptBALWETH")

#dfamm <- df %>% filter(reserve == "AmmBptBALWETH" )

#amm.plot <- ggplot(dfamm, aes(x = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSD)) + #geom_line() + geom_point(data = dfamm, aes(x = as_datetime(timestamp, tz = "UTC"), y = #reservePriceUSDCollateral), color = "red") + ggtitle("Price and Deficient Liquidations of #AmmBptBALWETH") + ylab("Price of AmmBptBALWETH, USD") + xlab("Time")

#ggplotly(amm.plot)

#amm.plot

```
The two graphs above (the third one is commented out for technical reasons) were inspired by the following paper: https://arxiv.org/pdf/2106.06389.pdf. The paper, among many other things, proposes the hypothesis for why we could observe non-profitable(deficient) liquidations. According to their explanation, the reason might be just small flucluations in price of collateral reserves over time. In order to check this hypothesis, I decided to build graphs of price for different coins and put red points at places where deficient liquidations occurred. The reserves were selected based on popularity of collateral in deficient liquidations.

We can somewhat verify the hypothesis from the paper: it looks like a lot of liquidations occur when price drops (at least for XSUSHI). However, we definitely cannot say that the price of collateral explains all deficient liquidations. The price curve for ENJ is much more flat and it looks like most of the liquidations for this reserve did not occur when price dropped.

It is quite hard to study these curves in more details as we do not know prices of reserves at all times: the graphs were built from limited available information. So, we cannot always clearly say whether price really dropped or went up (AmmBptBALWETH graph was commented out since it was even more discontinuous). For the same reason, I do not include graphs with collateral-principal price ratio, which would otherwise be very useful.
```{R}
#Other interesting graphs from that paper

dfl <- df %>% filter(type == "liquidation")
dfl <- dfl %>%  mutate(timestamp = as_datetime(timestamp, tz = "UTC"))

#dfl

dftl <- dfl %>% group_by(month = lubridate::floor_date(timestamp, "month")) %>% summarize(total_profit = sum(amountUSDCollateral) - sum(amountUSDPincipal))

dfweek <- dfl %>% group_by(week = lubridate::floor_date(timestamp, "week")) %>% summarize(total_profit = sum(amountUSDCollateral) - sum(amountUSDPincipal))

#dfweek

dfcum <- dfl %>% arrange(timestamp)

dfcum <- dfcum %>% mutate(cum_collateral = cumsum(amountUSDCollateral))

library(scales)

plot_tl <- ggplot(dftl, aes(x = month, y = total_profit)) + geom_bar(stat="identity", position=position_dodge()) + ggtitle("Profit from Liquidations") + ylab("Monthly Profit (USD)") + scale_x_datetime(breaks=date_breaks("1 month"), labels=date_format("%b")) + xlab("Month")

plot_tlw <- ggplot(dfweek, aes(x = week, y = total_profit)) + geom_bar(stat="identity", position=position_dodge()) + ggtitle("Profit from Liquidations") + ylab("Weekly Profit (USD)") + xlab("Weekly")

plot_t2 <- ggplot(dfcum, aes(x = timestamp, y = cum_collateral)) + geom_line() + ggtitle("Collateral Sold Through Liquidations") + ylab("Accumulative Collateral (USD)") +scale_x_datetime(breaks=date_breaks("1 month"), labels=date_format("%b")) + xlab("Time")

df_bor_avg = df %>% filter(type == "borrow") %>%  mutate(timestamp = as_datetime(timestamp, tz = "UTC")) %>% group_by(month = lubridate::floor_date(timestamp, "month")) %>% summarize(total_borrow = sum(amountUSD))

#df_bor_avg

df_bor_liq = cbind(dftl,df_bor_avg)

df_bor_liq <- df_bor_liq[, !duplicated(colnames(df_bor_liq), fromLast = TRUE)] 

df_bor_liq <- df_bor_liq %>% mutate(ratio = total_profit/total_borrow)

library(scales)

plot_t3 <- ggplot(df_bor_liq, aes(x = month, y = ratio)) + geom_line() + ggtitle("Comparison Between Monthly Collateral Profit and Monthly Borrow Volume") + ylab("Monthly Profit-Volume Ratio") + xlab("Month") +scale_x_datetime(breaks=date_breaks("1 month"), labels=date_format("%b"))

plot_tl

plot_tlw

plot_t2

plot_t3

#dfcum

```
The graphs above were inspired by this paper: https://arxiv.org/pdf/2106.06389.pdf. The idea was to try to see what graphs might be useful for the app (for liquidations section). It turned out that a lot of graphs from paper cannot really be built with the data we currently have. However, I was able to build several graphs, which look very interesting. I do not have a lot to say about the contents of the graphs: we have seen most of the trends these graphs show before. I, personally, like the cumulative graph and find it very informative not only for liquidations, but for other transactions as well.
```{R}
dfcumUSDC <- dfl %>% arrange(timestamp) %>% filter(collateralReserve == "USDC")
dfcumUSDC <- dfcum %>% mutate(cum_collateral = cumsum(amountUSDCollateral))

dfcumDAI <- dfl %>% arrange(timestamp) %>% filter(collateralReserve == "DAI")
dfcumDAI <- dfcumDAI %>% mutate(cum_collateral = cumsum(amountUSDCollateral))

dfcumWETH <- dfl %>% arrange(timestamp) %>% filter(collateralReserve == "WETH")
dfcumWETH <- dfcumWETH %>% mutate(cum_collateral = cumsum(amountUSDCollateral))

plot_t4 <- ggplot(dfcumUSDC, aes(x = timestamp, y = cum_collateral)) + geom_line() + geom_line(data = dfcumDAI, aes(x = timestamp, y = cum_collateral)) + geom_line(data = dfcumWETH, aes(x = timestamp, y = cum_collateral)) + ggtitle("Collateral Sold Through Liquidations") + ylab("Accumulative Collateral (USD)") +scale_x_datetime(breaks=date_breaks("1 month"), labels=date_format("%b")) + xlab("Time")

df_bor_avg = df %>% filter(type == "borrow") %>%  mutate(timestamp = as_datetime(timestamp, tz = "UTC")) %>% group_by(week = lubridate::floor_date(timestamp, "week")) %>% summarize(total_borrow = sum(amountUSD))

#df_bor_avg

#plot_t4
```

```{R}
dfst <- df %>% filter(type == "liquidation") %>%  filter(collateralReserve == "WETH")

dfst$collateralType <- mapply(coinType, dfst$collateralReserve)
dfst$principalType <- mapply(coinType, dfst$principalReserve)

dfstweth <- dfst %>% filter(collateralReserve == "WETH")

dfweth <- df %>% filter(reserve == "WETH")

#dfstweth

r <- 500
weth.plot <- ggplot(dfweth, aes(x  = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSD*r)) + geom_line() + geom_point(data = dfstweth, aes(x = as_datetime(timestamp, tz = "UTC"), y = amountUSDCollateral), color = "red") + ggtitle("Price and Liquidations of WETH as Collateral") + ylab("Collateral in Liquidation, USD") + xlab("Time") + scale_y_continuous(labels = comma, sec.axis = sec_axis(~./r, name = "Price of WETH, USD"))

#ggplotly(weth.plot)

weth.plot

dfstweth <- dfstweth %>% mutate(timestamp = as_datetime(timestamp, tz = "UTC"))

dfstweth <- dfstweth %>% mutate(week = lubridate::floor_date(timestamp, "week"), day = lubridate::floor_date(timestamp, "day"))

dfplotday <- dfstweth %>% group_by(day) %>% summarize(daily_liquid = sum(amountUSDCollateral))

dfplotweek <- dfstweth %>% group_by(week) %>% summarize(weekly_liquid = sum(amountUSDCollateral))

r <- 2000
weth.plotday <- ggplot(dfweth, aes(x  = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSD*r)) + geom_line() + geom_line(data = dfplotday, aes(x = day, y = daily_liquid), color = "red") + ggtitle("Price and Liquidations of WETH as Collateral") + ylab("Daily Total Collateral in Liquidations, USD") + xlab("Time") + scale_y_continuous(labels = comma, sec.axis = sec_axis(~./r, name = "Price of WETH, USD"))

r <- 4000
weth.plotweek <- ggplot(dfweth, aes(x  = as_datetime(timestamp, tz = "UTC"), y = reservePriceUSD*r)) + geom_line() + geom_line(data = dfplotweek, aes(x = week, y = weekly_liquid), color = "red") + ggtitle("Price and Liquidations of WETH as Collateral") + ylab("Weekly Total Collateral in Liquidations , USD") + xlab("Time") + scale_y_continuous(labels = comma, sec.axis = sec_axis(~./r, name = "Price of WETH, USD"))

weth.plotday

weth.plotweek 

```
These three graphs were inspired by different paper: https://arxiv.org/pdf/2009.13235.pdf.
The idea was, again, to see if we can use these kinds of graphs in our app. I used some variation of Cole Pacquin's code for the second axis. The black line shows the price of WETH and red points or lines show amount of collateral in liquidations.

Speaking of the second graph (daily liquidations), it looks like we can say something about relationship between price of collateral reserve and liquidations. From the graph, we can see that there are spikes in daily total collateral amounts usually at times when collateral price drops. However, it is not always true: the spike in April seems to be one counterexample.

### Good Liquidators
```{R}
#Good liquidators: those that make profit from liquidations
#Extension from previous work

dfl <- df %>% filter(type == "liquidation") %>% group_by(user_alias) %>% summarize(total_collateral = sum(amountUSDCollateral), total_principal = sum(amountUSDPincipal), avg_collateral = mean(amountUSDCollateral), avg_principal = mean(amountUSDPincipal), num_transact = n()) %>% mutate (total_profit = total_collateral - total_principal, avg_profit = avg_collateral - avg_principal)

dfl <- dfl[order(-dfl$total_profit),]

dfl <- dfl %>% filter(total_profit > 100000 )

#dfl

plot_liq <- dfl %>% ggplot(aes(x = total_collateral, y = num_transact, color = total_profit)) + geom_point() + scale_color_gradientn(colours = rainbow(5)) + labs(title = "Good Liquidators", x = "Total Collateral(USD)", y =  "Number of Liquidations", color = "Total Profit")

plot_liq

dfl_all <- df %>% filter(df$user_alias %in% dfl$user_alias)

#dfl_all

bd_liq <- dfl_all %>% group_by(type) %>% summarize(n=n())%>% mutate(percent = n/sum(n)*100)

bd_liq$group <-'good_liquidators'

bd_joint <- rbind(bd_joint,bd_liq) 

plot <- ggplot(data=bd_joint, aes(x=type, y=percent, fill=group)) +
geom_bar(stat="identity", position=position_dodge()) + ggtitle("Deficient Liquidators, Best Liquidators, and All Users \n by Types of Transactions")

plot

```


The graph and barplot above show the information on best liquidators(liquidators that made at least 100000 USD profit from liquidations). The plot compares number of liquidations and total collateral claimed in all of liquidations for best liquidators. Colors correspond to amount of profit (collateral - principal) gained in these transactions.

One trend that we observe is that the most profitable liquidators (green, blue, purple points on graph) all have more than 10 liquidations and, most importantly, also claimed a lot of collateral. So, it looks like liquidators have to liquidate loans of high volume in order to make most of the profit. The strategy of just doing a lot of low-volume liquidations does not show to be profitable.  

The barplot extends the barplot from the beginning of this notebook by adding good_liquidators column. So, we can now compare all three groups: deficient liquidators, good(best) liquidators, and regular users. As we can see from the barplot, all three groups look very different in terms of types of transactions they do. Speaking of good liquidators in particular (the two other groups were summarized above), they seem to do less liquidations compared to deficient liquidators. We can guess that they probably aim for high-volume liquidations more rather than number of liquidations and also they probably do a lot of other transactions just to collect more profit. High numbers for borrow and repay could have the following explanation: good liquidators have to borrow a lot in order to collect money for liquidation, once a loan is liquidated they pay back the loans.
```{R}
#Time-series plot good vs normal liquidations
dfl_all_time <- dfl_all %>% filter(type == "liquidation")

count(dfl_all_time)

dfliq <- df %>% filter(type == "liquidation")

count(dfliq)

#print(dfliq)

dfl_time_plot <- ggplot(data = dfliq, aes(x = as_datetime(timestamp, tz = "UTC"),y = amountUSDCollateral)) + geom_point() + geom_point(data = dfl_all_time, color = "red") + labs(title = "Liquidations over Time", x = "Time", y =  "Collateral in Liquidation (USD)", color = "Group")

dfl_time_plot

```
Let's now compare how many liquidations are due to good liquidators. First, let's take a look at the graph of liquidations over time. The black points are liquidations by all users and red points are liquidations by the good liquidator group. Visually, it looks like good liquidators make about 50% of liquidations, which is not true. Actually, there are only 547 liquidations from good liquidators, whereas all users made 6731 liquidations total (so about 8% are from good liquidators). Another interesting observation is that all points that have a lot of collateral are red, which means good liquidators focus more on those types of liquidations (and make their profit due to doing these liquidations). The high-volume liquidations are possible only at times of instability (i.e. Chinese Crypto Ban), which is very good for liquidators.

### Important Factors for Deficient Liquidations

```{R}
#function to mark stable and non-stable coins
coinType <- function(coin) {
    #stable_coins <- list("USDC","USDT","DAI","BUSD","SUSD","GUSD","TUSD")
    if(str_contains(coin,"USD",ignore.case = TRUE))
    {
      result = "stable"
    }
    else if(str_contains(coin,"DAI",ignore.case = TRUE))
    {
      result = "stable"
    }
    else
    {
      result = "non-stable"
    }
    return(result)
}
```

Let's start by building a dataframe for deficient liquidations and computing the percentage of deficient liquidations over all liquidations.

```{R}
#Show transactions, where collateral<principal (exclude WETH and AmmWETH for now). 
dfst <- df %>% filter(type == "liquidation") %>% filter(collateralReserve != "WETH") %>% filter(principalReserve != "WETH")%>% filter(collateralReserve != "AmmWETH") %>% filter(principalReserve != "AmmWETH") %>% filter(amountUSDCollateral<amountUSDPincipal)

dfst$collateralType <- mapply(coinType, dfst$collateralReserve)
dfst$principalType <- mapply(coinType, dfst$principalReserve)

dfs <- df %>% filter(type == "liquidation")

#Count total liquidation 
count(dfst)/count(dfs)

```
As we can see, there are about 2.3% of deficient liquidations over the whole data set, which is a relatively high number. This even excludes our problematic data on WETH and AmmWETH.

```{R}
#Show just random 10 of those (exclude some data)
dfst %>% select(collateralReserve,principalReserve,amountUSDCollateral,amountUSDPincipal) %>% head(10)

#dfst %>% select(collateralReserve,principalReserve,amountUSDCollateral,amountUSDPincipal)[order(-dfst$amountUSDPincipal),]

plot1 <- ggplot(dfst,aes(x = amountUSDPincipal, y = amountUSDCollateral,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidations with Collateral below Principal") + geom_abline() + xlab("Principal (USD)") + ylab("Collateral (USD)")

plot1

dfst2 <- dfst %>% filter(amountUSDPincipal < 250000)

plot2 <- ggplot(dfst2,aes(x = amountUSDPincipal, y = amountUSDCollateral,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidations with Collateral below Principal (no outliers)") + geom_abline() + xlab("Principal (USD)") + ylab("Collateral (USD)")

plot2

```
We can take a look into how deficient liquidations are distributed. First of all, there are just a few liquidations with very high collateral and principal value. Most of the deficient liquidations are below $100000 in principal. Second, we see that there are no deficient liquidations, where both collateral and principal are stable coins. This is probably just because there are very little (stable,stable) liquidations in general. Lastly, we observe that some complicated distribution in terms of distance from the identity line. There are some deficient liquidations that are extremely close to the identity line, but there are also a lot of deficient liquidations that are quite distant from it.
```{R}
#function to mark deficient/regular liquidations
defLiquid <- function(principal, collateral) {
  if(collateral < principal)
  {
    result = TRUE
  }
  else
  {
    result = FALSE
  }
  return(result)
}

dfl <- df %>% filter(type == "liquidation") %>% filter(collateralReserve != "WETH") %>% filter(principalReserve != "WETH") %>% filter(collateralReserve != "AmmWETH") %>% filter(principalReserve != "AmmWETH") 

dfl$deficiency <- mapply(defLiquid,dfl$amountUSDPincipal,dfl$amountUSDCollateral)

#plot of regular vs deficient liquidations

plot3 <- ggplot(dfl,aes(x = amountUSDPincipal, y = amountUSDCollateral,color = deficiency)) + geom_point() + ggtitle("Regular vs Deficient Liquidations") + geom_abline() + xlab("Principal (USD)") + ylab("Collateral (USD)")

plot3

#plot of liquidations over time

plot4 <- ggplot(dfl,aes(y = amountUSDPincipal,x = as_datetime(timestamp, tz = "UTC"),color = deficiency)) + geom_point() + ggtitle("Regular vs Deficient Liquidations over Time") + geom_abline() + xlab("Time") + ylab("Principal (USD)")

plot4

```
We can take a look into deficient vs regular liquidations. Unsurprisingly, we see that deficient liquidations are only represented when the amount of transactions is very small compared to regular liquidations. If we look into liquidations over time, we can observe a few trends. The regular ggplot makes it harder to see (compared to ggplotly), but we can still see that all liquidations both deficient and regular are distributed non-equally (due to spikes). However, we still observe that deficient liquidations occurred in different times from January through July and August. Another interesting observation is that it seems like deficient liquidations often occur in pairs and triples (within the same day or two days), but I do not know if this is really true and how to explain it.
```{R}

dfl <- dfl %>% filter(deficiency == TRUE) %>% mutate(percent = amountUSDCollateral*100/amountUSDPincipal)

#dfl$percent <- format(dfl$percent,scientific = FALSE)


dfl$principalType <- mapply(coinType, dfl$principalReserve)
dfl$collateralType <- mapply(coinType, dfl$collateralReserve)

#plot this graph, excluding outliers, so it is easier to see
plot5 <- ggplot(dfl%>%filter(amountUSDPincipal < 250000),aes(x = percent,y = amountUSDPincipal, color = collateralType, shape = principalType)) + geom_point() + ggtitle("Deficient Liquidations by Percent (No Outliers)") + geom_abline() + ylab("Principal (USD)") + xlab("Collateral-Principal Ratio(%)")

plot5


```
In order to study the deficient liquidations in more detail, we can take a look into collateral-principal ratio. Collateral-principal ratio is defined as collateral(USD)/principal(USD). So, this ratio, expressed as percent, is always less than 100% for deficient liquidations. From the plot, we can observe that distribution (in horizontal axis) seems to be more or less uniform, at the very least there is no significant bias towards 100% as I would expect. One interesting detail to observe is that there is a gap in deficient liquidations between about 35% to 43% in collateral-principal ratio. 
```{R}

#We have to reload data for new analysis

#data collection as always
#df2<-read_rds('../../DefiResearch/transactions2.Rds')  
# Use deplyr to drop NA reserves, add the counts and then kep only the top 20
reservecoins <- df %>%  drop_na(reserve) %>% 
count(reserve) %>% 
arrange(-n) %>% 
head(20)



```

```{R}

#Let's try logistic regression on data

#dfl <- df %>% filter(type == "liquidation")

dfll <- df %>% filter(type == "liquidation") %>% filter(collateralReserve != "WETH") %>% filter(principalReserve != "WETH") %>% filter(collateralReserve != "AmmWETH") %>% filter(principalReserve != "AmmWETH") %>% mutate(percent = amountUSDCollateral/amountUSDPincipal)

dfll$deficiency <- mapply(defLiquid,dfll$amountUSDPincipal,dfll$amountUSDCollateral)
dfll$principalType <- mapply(coinType, dfll$principalReserve)
dfll$collateralType <- mapply(coinType, dfll$collateralReserve)

dfll<-dfll %>% mutate(defNum = ifelse(deficiency == TRUE, 1, 0) )
dfll<-dfll %>% mutate(princTypeNum = ifelse(principalType == "stable", 1, 0) )
dfll<-dfll %>% mutate(collatTypeNum = ifelse(collateralType == "stable", 1, 0) )



model <- glm(defNum ~ timestamp + collateralAmount + principalAmount + reservePriceETHPrincipal + reservePriceETHCollateral, data = dfll, family = binomial, maxit = 100)

summary(model)




dfll<- dfll %>% mutate(priceRatio =  reservePriceETHCollateral/reservePriceETHPrincipal, amountRatio = collateralAmount/principalAmount)

model1 <- glm(defNum ~ priceRatio, data = dfll, family = binomial, maxit = 100)

summary(model1)

#model2 <- glm(defNum ~ priceRatio, data = dfll, family = binomial, maxit = 100)

model2 <- glm(defNum ~ collateralAmount + principalAmount + reservePriceETHPrincipal + reservePriceETHCollateral + princTypeNum + collatTypeNum, data = dfll, family = binomial, maxit = 100)

summary(model2)

model3 <- glm(defNum ~ timestamp + priceRatio + collateralAmount + principalAmount + reservePriceETHPrincipal  + princTypeNum + collatTypeNum, data = dfll, family = binomial, maxit = 100)

summary(model3)


```
We can take a look into what factors are important for deficient liquidations. We can verify it by looking into different models using logistic regression. We additionally introduce new feature - price ratio (ratio of prices of principal and collateral coins). The results of trying different models (different features), but we probably want to look into the last model that includes most features. We obviously want to exclude percent (collateral-principal ratio) from the analysis, as it would reveal the way deficient liquidations are defined. As we can see, logistic regression proves the importance of time (which we already observed above) and price ratio (price ratio has extremely good p-value), we also see that principal and collateral type both have some statistical significance. Other factors seem to have little to no influence on the results.

```{R}

set.seed(2)

#data separation, done from r
ind <- sample(c(rep(TRUE,ceiling(nrow(dfll)*0.8)),rep(FALSE,floor(nrow(dfll)*0.2))))
data1 <- dfll[ind, ] 
data2 <- dfll[!ind, ] 

model4 <- glm(defNum ~ timestamp + priceRatio + collateralAmount + principalAmount + reservePriceETHPrincipal  + princTypeNum + collatTypeNum, data = data1, family = binomial, maxit = 100)

model4b <- rpart(defNum ~ timestamp + priceRatio + collateralAmount + principalAmount + reservePriceETHPrincipal  + princTypeNum + collatTypeNum, data = data1)

model4c <- randomForest(defNum ~ timestamp + priceRatio + collateralAmount + principalAmount + reservePriceETHPrincipal  + princTypeNum + collatTypeNum, data = data1)

summary(model4)
#summary(model4b)
summary(model4c)

#summary(model4b)

result <- predict(model4,data2,type = "response")

#resultb <- predict(model4b,data2)

print(head(result,10))

data2<- data2 %>% mutate(predictedValue = predict(model4,data2,type = "response"))

data2<- data2 %>% mutate(predictedResult = ifelse(predictedValue>0.5,TRUE,FALSE))

data2<- data2 %>% mutate(predictedValue2 = predict(model4b,data2))

data2<- data2 %>% mutate(predictedResult2 = ifelse(predictedValue2>0.5,TRUE,FALSE))

data2<- data2 %>% mutate(predictedValue3 = predict(model4b,data2))

data2<- data2 %>% mutate(predictedResult3 = ifelse(predictedValue3>0.5,TRUE,FALSE))

head(data2 %>% select(deficiency, predictedValue, predictedResult, predictedValue2, predictedResult2, predictedValue3,predictedResult3),10)


#Logistic Regression Accuracy
count(data2 %>% filter(predictedResult == deficiency))/count(data2)

#Regression Tree Accuracy
count(data2 %>% filter(predictedResult2 == deficiency))/count(data2)

#Random Forest Accuracy
count(data2 %>% filter(predictedResult3 == deficiency))/count(data2)




```

In order to measure accuracy of the logistic regression model, we can try how well it predicts the data using those features. We introduce two more algorithms for classification: regression trees and random forest. We built all three models using the same features (as above). Additionally we separate data into testing and training sets. The resulting models and accuracy of each algorithm can be observed above (summary for regression trees is commented out as it is very lengthy). Due to very unbalanced nature of our data (98% vs 2%), logistic regression marks all liquidations as False, which still gives it high accuracy. The other two algorithms seem to both perform slightly better and they not always mark data points as False. In general, it is probably not the best idea to train classification models on such an unbalanced datasets -- a good idea would be to balance data, but, unfortunately, we only have about 150 deficient observations, which is really small. 

### Other Work on Liquidations

```{r}
#Create cointype function to label all coins by types correctly,
#This is useful for visualizations

coinType <- function(coin) {
    #stable_coins <- list("USDC","USDT","DAI","BUSD","SUSD","GUSD","TUSD")
    if(str_contains(coin,"USD",ignore.case = TRUE))
    {
      result = "stable"
    }
    else if(str_contains(coin,"DAI",ignore.case = TRUE))
    {
      result = "stable"
    }
    else
    {
      result = "non-stable"
    }
    return(result)
}

#Main data frame for analysis of liquidations, includes information on total and
#average values of collateral and principal

LiquidSummary <- df%>% filter(type == "liquidation") %>% group_by(collateralReserve, principalReserve)

LiquidSummary <- df%>% filter(type == "liquidation") %>% group_by(collateralReserve, principalReserve) %>% summarize(avg_usd_princ = mean(amountUSDPincipal),total_usd_princ = sum(amountUSDPincipal), avg_usd_collat=mean(amountUSDCollateral),total_usd_collat=sum(amountUSDCollateral),avg_eth_princ = mean(reservePriceETHPrincipal*principalAmount),total_eth_princ = sum(reservePriceETHPrincipal*principalAmount), avg_eth_collat=mean(reservePriceETHCollateral*collateralAmount),total_eth_collat=sum(reservePriceETHCollateral*collateralAmount),collateralType = coinType(collateralReserve), principalType = coinType(principalReserve),n=n())

#These are just ordered versions of LiquidSummary too see what coins are used
#more for liquidations
LiquidSummary <- LiquidSummary[order(-LiquidSummary$total_usd_princ),]
print(head(LiquidSummary,5))

LiquidSummary <- LiquidSummary[order(-LiquidSummary$total_usd_collat),]
print(head(LiquidSummary,5))
```

These tables provide the initial analysis for liquidation coins. The first table shows the first five entries of the data frame ordered by total principal (in USD), while the second table shows the same but for total collateral (in USD). From these, we can initially draw some basic conclusion. First, almost all combinations of coins have non-stable coin for collateral and stable coin for principal. Second, we can observe popular coins for collateral and principal, these are WBTC, WETH for collateral and USDC, USDT for principal. Lastly, we see that different combinations of coins, even ordered, are still quite different. For example, combinations (WETH,USDT) and (WBTC,USDC) are very different in average value for principal while quite close in total value for principal.

```{r}

#ggplotly() alternatives are commented out to ease reading

#Build plots for total principal/ total collateral (USD)

p <- ggplot(LiquidSummary,aes(x = total_usd_princ, y = total_usd_collat,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidation Coins (Total Value)") + geom_text_repel(aes(label=ifelse(total_usd_princ>1.0e+07|total_usd_collat>1.0e+07,paste(as.character(collateralReserve), as.character(principalReserve), sep=";"),'')),hjust=0,vjust=1) + geom_abline() + xlab("Total Principal (USD)") + ylab("Total Collateral (USD)")

p <- p + coord_equal(ratio = 1) 

#Build plots for total principal/ total collateral (ETH)
p_eth <- ggplot(LiquidSummary,aes(x = total_eth_princ, y = total_eth_collat,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidation Coins (Total Value in ETH)") + geom_text_repel(aes(label=ifelse(total_eth_princ>2.0e+07|total_eth_collat>2.0e+05,paste(as.character(collateralReserve), as.character(principalReserve), sep=";"),'')),hjust=0,vjust=1) + geom_abline() + xlab("Total Principal (ETH)") + ylab("Total Collateral (ETH)")



p_eth <- p_eth + coord_equal(ratio = 1)


LiquidNCollat <- LiquidSummary %>% group_by(collateralReserve) %>% summarize(total_liquidations = sum(n))

LiquidNCollat <- LiquidNCollat[order(-LiquidNCollat$total_liquidations),]

LiquidNPrinciple <- LiquidSummary %>% group_by(principalReserve) %>% summarize(total_liquidations = sum(n))

LiquidNPrinciple <- LiquidNPrinciple[order(-LiquidNPrinciple$total_liquidations),]

p

#This graph is almost the same, so commented out
#p_eth

#ggplotly(p)

p_avg <- ggplot(LiquidSummary,aes(avg_usd_princ,avg_usd_collat,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidation Coins (Average Value)") + geom_text(aes(label=ifelse(avg_usd_princ>2.0e+05|avg_usd_collat>2.0e+05,paste(as.character(collateralReserve), as.character(principalReserve), sep=";"),'')),hjust=0,vjust=1) + geom_abline()  + xlab("Average Principal (USD)") + ylab("Average Collateral (USD)")

#ggplotly(p2)

p_avg
```
The two graphs support our observations from the tables above. Additionally, we can see some other interesting trends. 

From the graph on the total value we can deduce that almost all combinations of coins (except for erroneous WETH combinations) lie above the diagonal identity line. This means that in total value, collateral is always higher than principal (the ratio is actually about 1.1-1.15 for most combinations).

However, the graph on the average values shows something even more interesting: there are some combinations of coins (not including WETH ones), where average principal is higher than average collateral (for example (XSUSHI,BUSD)). This is very interesting thend that cannot be explained from just mathematics: if every transaction has a higher principal than collateral then the total should also behave the same way, which implies average should also follow the same trend. Aaron proposed an interesting explanation to this: if there are multiple borrows with different types of collateral/principle taken for the same user simultaneously, the health factor might be computed based on different coins, which would potentially allow for this situation to happen. However, this still does not explain why liquidators chose these coins because this is not profitable economically. 

```{R}
#Show transactions, where collateral<principal (exclude WETH for now). 
dfst <- df %>% filter(type == "liquidation") %>% filter(collateralReserve != "WETH") %>% filter(principalReserve != "WETH") %>% filter(amountUSDCollateral<amountUSDPincipal)

count(dfst)

#Show just random 10 of those (exclude some data)
dfst %>% select(collateralReserve,principalReserve,amountUSDCollateral,amountUSDPincipal) %>% head(10)


```
Continuing this discussion on strange behavior of some coin combinations, we can take a look at individual liquidation transactions. This includes all transactions where collateral<principal and this also excludes WETH. Turns out there are 169 transaction like that. Almost all transactions include at least one unpopular coin (which means this particular coin combination is also unpopular), which might explain this partially. This behavior is to be analyzed in details next week.
```{r}

#df<-df %>% filter(type == "liquidation") %>% group_by(timestamp, reserveUSDPrincipal) %>% filter(collateralReserve == "WBTC") %>% filter(principalReserve == "USDC")

#df <- df %>% mutate(timestamp = as_date(timestamp))

#LiquidSummary2 and dfl are dataframes for analyzing data over time

LiquidSummary2 <- LiquidSummary %>% mutate(collat_princ_rat = total_usd_collat/total_usd_princ)

#LiquidSummary2

dfl<-df %>% filter(type == "liquidation") 
  
dfl$collateralType <- mapply(coinType, dfl$collateralReserve)

dfl$principalType <- mapply(coinType, dfl$principalReserve)

#Change timestamp to show actual dates instead of timestamps 
dfl<-dfl %>% mutate(timestamp = as_datetime(timestamp, tz = "UTC"))

#head(dfl,20)

#make a plot for liquidations over time (color and shape appropriate coin types)
p <- ggplot(dfl,aes(x = timestamp, y = amountUSDPincipal,color = collateralType, shape = principalType)) + geom_point() + ggtitle("Liquidation Transactions in 2021") +  geom_text_repel(aes(label=ifelse(amountUSDPincipal>2.0e+06,paste(as.character(collateralReserve), as.character(principalReserve), sep=";"),'')),hjust=0,vjust=1) + xlab("Time") + ylab("Amount principal (USD)")

p

#Same plots to be done for p2 and p3

BorrowSummary <- df %>% filter(type == "borrow")

BorrowSummary$type <- mapply(coinType,BorrowSummary$reserve)

p2 <- ggplot(BorrowSummary,aes(x = as_datetime(timestamp, tz = "UTC"), y = amountUSD, color = type)) + geom_point() + ggtitle("Borrow value by time") + xlab("Time") + ylab("Amount (USD)")

p2

RepaySummary <- df %>% filter(type == "repay")

RepaySummary$type <- mapply(coinType,RepaySummary$reserve)

p3 <- ggplot(RepaySummary,aes(as_datetime(timestamp, tz = "UTC"), y = amountUSD, color = type)) + geom_point() + ggtitle("Repay value by time") + xlab("Time") + ylab("Amount (USD)")

p3
             
```

These graphs show different types of transactions over time. I was focusing more on liquidations, but also made similar graphs for borrow and repay for comparison. The liquidation graph looks very interesting. In general, it is more or less flat, sometimes we see some spikes, but there is a big spike around the middle of May, 2021. This period is very different on the graph: we see both a lot more transactions than usual and also a lot of transactions of high volume. This hypothesis for this event is ban of cryptocurrency operations by China, which happened on May 18. It looks like WETH and WBTC coins got liquidated a lot, but liquidations actually occurred in many different coin combinations.

Unlike the liquidation graph, borrow and repay graphs look differently. We see some increase in total number of transactions (and also value) starting from early May, but we do not see so high spikes and also transaction behavior remains the same after May unlike liquidation transactions, which got back to normal level after May. The reason could be high volatility of liquidation market (even slight difference causes great changes to the market).
